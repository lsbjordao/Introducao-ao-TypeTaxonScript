[
  {
    "objectID": "contexto.html",
    "href": "contexto.html",
    "title": "Contexto",
    "section": "",
    "text": "Ambiente JavaScript e Node.js\nO JavaScript (ECMA International 2023) serve como base para uma ampla variedade de iniciativas modernas em programação, incluindo o gerenciamento de dados biológicos (Janicki et al. 2016; Lin and Gebaly 2016; DiPierro 2018). Sua versatilidade e ampla adoção impulsionaram o desenvolvimento de ferramentas e plataformas que exploram suas capacidades.\nO Node.js, um ambiente de execução construído sobre o motor V8 do Chrome, amplia o potencial do JavaScript além dos navegadores (Node.js Contributors 2023). Ele permite a execução de código JS fora dos navegadores, facilitando a criação de scripts do lado do servidor. Isso é particularmente vantajoso para tarefas que envolvem processamento de dados, requisições de API e gerenciamento de bancos de dados (DiPierro 2018). Além disso, o Node.js oferece acesso a uma ampla gama de bibliotecas e pacotes, acelerando o desenvolvimento de bases de dados e ampliando suas funcionalidades.\nJavaScript e Node.js são ferramentas poderosas no campo do gerenciamento de dados biológicos. Suas capacidades contribuem para o desenvolvimento de bancos de dados eficientes, dinâmicos e escaláveis, facilitando avanços na pesquisa em biodiversidade.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#programação-orientada-a-objetos-e-typescript",
    "href": "contexto.html#programação-orientada-a-objetos-e-typescript",
    "title": "Contexto",
    "section": "Programação Orientada a Objetos e TypeScript",
    "text": "Programação Orientada a Objetos e TypeScript\nNo campo em constante evolução do gerenciamento de dados biológicos, a fusão dos princípios da Programação Orientada a Objetos (POO) com o TypeScript, uma poderosa extensão da linguagem, representa um avanço significativo. A POO, um paradigma de desenvolvimento de software, gira em torno da representação de entidades do mundo real como objetos, cada um com atributos e métodos distintos (Wegner 1990; Sequeira, Olson, and McKinion 1997). Essencialmente, a POO baseia-se em classes e instâncias, onde cada objeto representa uma instância de uma classe. Esse paradigma promove reutilização de código, modularidade e manutenção facilitada, oferecendo ferramentas indispensáveis para lidar com a complexidade dos dados biológicos. A integração dos princípios da POO nos sistemas de informação biológica tem sido utilizada para combinar fontes e interações de dados diversas (Sequeira, Olson, and McKinion 1997; Bedathur, Haritsa, and Sen 2003; Onkov 2011; Tylman 2016).\nO TypeScript, como extensão do JavaScript estreitamente ligado à POO, eleva as capacidades da linguagem ao introduzir recursos essenciais como tipagem estática e interfaces (Microsoft Corporation 2023). Essa melhoria torna o TypeScript uma ferramenta poderosa para a construção de sistemas complexos, robustos e bem organizados. Um aspecto notável do TS é sua capacidade de capturar erros em tempo de compilação, ao contrário do JS tradicional, que detecta erros em tempo de execução (Microsoft Corporation 2023). Essa característica melhora a identificação e resolução de problemas antes da execução do código, criando uma camada extra de verificação de código. Na construção e gerenciamento de bases de dados biológicas, essa detecção precoce de erros assegura a integridade dos dados e melhora a confiabilidade do sistema, especialmente em estruturas complexas e hierarquias típicas dos dados biológicos.\nNesse contexto, os métodos desempenham um papel crucial. Representando comportamentos associados às classes, eles funcionam como uma camada de validação em tempo de execução. Impõem condições e regras, garantindo a entrada de dados precisa e coerente. Por exemplo, quando a ausência de uma estrutura é declarada, como um tipo de tricoma vegetal, atribuir um tamanho a essa estrutura seria ilógico. Métodos funcionam como salvaguardas condicionais, prevenindo a entrada de dados errôneos ou incompatíveis. Assim, a qualidade e confiabilidade dos dados são significativamente aprimoradas.\nA combinação dos princípios da POO com as capacidades do TypeScript cria um conjunto de ferramentas potente para estruturar e gerenciar dados biológicos. Essa fusão dinâmica facilita a criação de um ecossistema ordenado e confiável, assegurando a precisão e integridade das informações sobre biodiversidade.\nDe forma semelhante, o TS introduz o conceito de “açúcar sintático”, aumentando a legibilidade e expressividade do código. Esse recurso adiciona elementos que facilitam a compreensão do código sem alterar seu comportamento fundamental. Por exemplo, a notação por ponto é significativamente mais intuitiva do que estruturas indentadas similares ao JSON. Esse refinamento sintático melhora a legibilidade para desenvolvedores e pesquisadores, mesmo aqueles com pouca experiência em programação. A integração do açúcar sintático harmoniza-se com os objetivos gerais do framework.\nOutro exemplo convincente de açúcar sintático está na adoção de convenções linguísticas da biologia. Em vez de tipos primitivos como true ou false, ou ainda 0 ou 1, sugerimos o uso de termos contextualizados como yes ou no, present ou absent. Essa abordagem ressoa com a linguagem utilizada nas análises comparativas das ciências biológicas. O alinhamento entre a semântica do código e os conceitos específicos da área reforça os objetivos do framework, promovendo um ambiente amigável voltado ao avanço da pesquisa em biodiversidade.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#banco-de-dados-orientado-a-documentos-e-json",
    "href": "contexto.html#banco-de-dados-orientado-a-documentos-e-json",
    "title": "Contexto",
    "section": "Banco de Dados Orientado a Documentos e JSON",
    "text": "Banco de Dados Orientado a Documentos e JSON\nA mudança de paradigma introduzida pelos bancos orientados a documentos (DOD) e a adoção do formato JSON tiveram um impacto profundo na gestão de dados biológicos. Ao contrário dos bancos relacionais tradicionais, os DOD armazenam dados como documentos independentes, abraçando a complexidade sem abrir mão da flexibilidade (Sequeira, Olson, and McKinion 1997; Chai, Wu, and Zhao 2013; Karnitis and Arnicans 2015; Chickerur, Goudar, and Kinnerkar 2015; Olivera et al. 2015; Mason 2015; Baazizi et al. 2019). Em um DOD não relacional, cada linha de uma planilha representa um documento no banco de dados, enquanto cada coluna representa uma propriedade desses documentos.\nNo cerne dessa transformação está o formato JSON, uma estrutura versátil e hierárquica capaz de acomodar dados diversos em um ambiente sem esquema fixo. Essa flexibilidade permite armazenar dados semiestruturados sem as limitações das tabelas predefinidas dos bancos relacionais (Baazizi et al. 2019). Assim, nuances que frameworks rígidos não conseguem capturar são representadas de forma mais precisa. A compatibilidade do JSON com as complexidades dos dados biológicos resulta numa representação mais rica e fiel das características biológicas. Isso contrasta fortemente com as dificuldades encontradas nos bancos relacionais para representar essas relações complexas sem estruturas convolutas e junções.\nEmbora os bancos relacionais sejam amplamente utilizados, inclusive na biologia, eles não oferecem a legibilidade que se alinha ao pensamento humano. A transição do pensamento bidimensional das planilhas para a notação hierárquica do JSON é claramente vantajosa, permitindo lidar melhor com a complexidade e criando uma estrutura mais legível e gerenciável.\nA base estrutural de um DOD consiste em um array de objetos, cada um tratado como um documento. Esse array constitui o banco de dados e exige robustas capacidades de consulta. Cada objeto recebe um índice específico. Ao trabalhar com DOD, nosso objetivo principal é navegar por todos os níveis da estrutura JSON. Isso envolve identificar o índice da consulta e o caminho no JSON que leva até ele. Esse duplo processo de recuperação proporciona um método preciso para acessar os dados desejados. Assim, o índice do documento e o caminho JSON são ferramentas fundamentais para navegação e consulta eficiente.\nNo JSON, um objeto é composto por pares chave-valor. A chave identifica exclusivamente um dado, e o valor representa a informação atribuída. Os valores podem incluir strings, números, booleanos, arrays, objetos JSON aninhados ou null. Essa estrutura facilita a organização e recuperação de dados com clareza.\nOutro ponto relevante é a contribuição do JSON para simplificar consultas. Utilizando a notação JSON, pesquisadores podem recuperar dados de forma eficiente. Bancos como o MongoDB (https://www.mongodb.com/) aproveitam o JSON para facilitar consultas e manipulação de dados, embora outras ferramentas neutras também possam ser utilizadas como linguagens de consulta.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#documentação-e-tsdoc",
    "href": "contexto.html#documentação-e-tsdoc",
    "title": "Contexto",
    "section": "Documentação e TSDoc",
    "text": "Documentação e TSDoc\nA documentação desempenha um papel essencial no armazenamento de informações sobre objetos, destacando seus atributos e valores. Isso é especialmente importante ao construir uma base de dados robusta com organização eficiente de metadados (Spinellis 2010; Rai, Belwal, and Gupta 2022; Warren et al. 2017).\nCriar documentação detalhada estabelece um guia de referência abrangente, descrevendo com precisão cada classe e seus atributos.\nO TSDoc funciona como uma ferramenta valiosa nesse contexto, oferecendo anotações padronizadas que esclarecem os atributos, incluindo seu tipo e finalidade. Isso promove consistência, auxiliando os colaboradores a entender o propósito de cada elemento.\nUma documentação sólida é essencial para desenvolver uma base de dados confiável. Ela assegura entradas corretas e mantém a integridade do sistema. Também facilita o trabalho em equipe, reduz erros e melhora a precisão dos dados.\nAo abordar a documentação em metadados e bancos de dados, constrói-se um framework que apoia a compreensão abrangente de objetos, atributos e métodos. A inclusão de anotações TSDoc aumenta essa clareza, padronizando descrições e tornando o acesso mais fácil.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#ambiente-de-desenvolvimento-integrado-e-visual-studio-code",
    "href": "contexto.html#ambiente-de-desenvolvimento-integrado-e-visual-studio-code",
    "title": "Contexto",
    "section": "Ambiente de Desenvolvimento Integrado e Visual Studio Code",
    "text": "Ambiente de Desenvolvimento Integrado e Visual Studio Code\nUm Ambiente de Desenvolvimento Integrado (IDE) é fundamental no desenvolvimento moderno, oferecendo ferramentas para codificação, depuração e colaboração. O VS Code (https://code.visualstudio.com/), da Microsoft, é um dos IDEs mais populares, conhecido por sua adaptabilidade e eficácia.\nSeu grande diferencial está na interface amigável e em sua capacidade de ser personalizado com extensões, cobrindo tarefas diversas em projetos TypeScript e além.\nNo nosso projeto, o VS Code é essencial para manipular dados biológicos no formato JSON. Integrando TS e Node.js, o IDE garante a manutenção e adaptabilidade do código — algo crucial para as demandas em evolução da pesquisa em biodiversidade. Outros IDEs também são capazes de cumprir essas funções.\nO VS Code ainda conta com controle de versão integrado, baseado em Git e GitHub. Isso facilita o compartilhamento, revisão e rastreamento de alterações, promovendo transparência e colaboração.\nA integração entre OOP, TS e JSON dentro do VS Code amplia as possibilidades de processamento, análise e uso dos dados biológicos, com simplicidade e eficiência, evitando a criação de softwares opinativos e favorecendo um framework robusto e adaptável.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#controle-de-versão-com-git-e-github",
    "href": "contexto.html#controle-de-versão-com-git-e-github",
    "title": "Contexto",
    "section": "Controle de Versão com Git e GitHub",
    "text": "Controle de Versão com Git e GitHub\nO uso estratégico de controle de versão contribui para um ambiente colaborativo e coerente. O GitHub, amplamente utilizado, integra-se ao VS Code, aumentando a eficiência e transparência (Blischak, Davenport, and Wilson 2016; Perez-Riverol et al. 2016; Crystal-Ornelas et al. 2021).\nEssa integração permite que pesquisadores colaborem facilmente, rastreando alterações e gerenciando contribuições. Os recursos de ramificação, pull requests e merge promovem colaboração eficiente, evitando erros e garantindo que as mudanças sejam testadas antes de entrar no código principal.\nAs branches permitem o desenvolvimento paralelo de diferentes aspectos da representação biológica. Já os pull requests viabilizam discussões e revisão de alterações, promovendo qualidade e transparência. O merge unifica essas contribuições, garantindo uma base coesa e fiel.\nO uso de rastreadores de issues, como o Git Issues, permite lidar com desafios na representação de conceitos biológicos. Ele organiza tarefas, diálogos e decisões, promovendo colaboração eficaz e melhoria contínua.\nO uso de Conventional Commits (https://www.conventionalcommits.org/) melhora a clareza das mensagens de commit e facilita a criação de históricos de mudanças automáticos. Isso torna o processo de revisão mais eficiente.\nEssa abordagem colaborativa tem grande potencial para impulsionar a pesquisa em biodiversidade e sistemática, promovendo inovação, escalabilidade e eficiência no desenvolvimento de bancos de dados biológicos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "contexto.html#exploração-do-banco-de-dados",
    "href": "contexto.html#exploração-do-banco-de-dados",
    "title": "Contexto",
    "section": "Exploração do Banco de Dados",
    "text": "Exploração do Banco de Dados\nExplorar novas abordagens em DOD é essencial. Esses bancos oferecem flexibilidade para lidar com dados não estruturados e semiestruturados — uma vantagem para estruturas de dados imprevisíveis ou em evolução. Eles representam diretamente hierarquias, arrays e documentos aninhados, e oferecem frameworks de agregação potentes.\nConsultas sofisticadas são fundamentais. O MongoDB exemplifica essa abordagem. Sua capacidade de lidar com esquemas adaptáveis e relações complexas está alinhada com as necessidades da análise biológica.\nDiversas bibliotecas facilitam consultas em JSON: JsonPath, Underscore e Lodash, por exemplo. Cada uma possui abordagens distintas, o que pode complicar a padronização. Ainda assim, oferecem alternativas valiosas para consultas eficientes.\nTécnicas padrão de consulta em DODs geralmente exigem o caminho completo das chaves. No entanto, nossa necessidade é diferente: queremos localizar pares chave-valor como {\"trichomes.setiform.are\": \"present\"} ou {\"obtainingMethod\": \"SEM\"}, independentemente da posição estrutural. Para isso, desenvolvemos uma função recursiva capaz de percorrer todos os níveis de um JSON, oferecida no TypeTaxonScript com o comando findProperty.\n\n\n\n\nBaazizi, Mohamed-Amine, Dario Colazzo, Giorgio Ghelli, and Carlo Sartiani. 2019. “Schemas and Types for JSON Data.” In Proceedings of the 2019 International Conference on Management of Data. ACM. https://doi.org/10.1145/3299869.3314032.\n\n\nBedathur, Srikanta J, Jayant R Haritsa, and Uday S Sen. 2003. “The Building of BODHI, a Bio-Diversity Database System.” Inf Syst 28 (4): 347–67. https://doi.org/10.1016/S0306-4379(02)00073-X.\n\n\nBlischak, John D., Emily R. Davenport, and Greg Wilson. 2016. “A Quick Introduction to Version Control with Git and GitHub.” Edited by Francis Ouellette. PLoS Comput 12 (1): e1004668. https://doi.org/10.1371/journal.pcbi.1004668.\n\n\nChai, Hualei, Gang Wu, and Yuan Zhao. 2013. “A Document-Based Data Warehousing Approach for Large Scale Data Mining.” In Pervasive Computing and the Networked World, 69–81. Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-642-37015-1_7.\n\n\nChickerur, Satyadhyan, Anoop Goudar, and Ankita Kinnerkar. 2015. “Comparison of Relational Database with Document-Oriented Database (MongoDB) for Big Data Applications.” In 2015 8th International Conference on Advanced Software Engineering & Its Applications (ASEA), 41–47. https://doi.org/10.1109/ASEA.2015.19.\n\n\nCrystal-Ornelas, Robert, Charuleka Varadharajan, Ben Bond-Lamberty, Kristin Boye, Madison Burrus, Shreyas Cholia, Michael Crow, et al. 2021. “A Guide to Using GitHub for Developing and Versioning Data Standards and Reporting Formats.” Earth Space Sci 8 (8). https://doi.org/10.1029/2021ea001797.\n\n\nDiPierro, Massimo. 2018. “The Rise of JavaScript.” Comput Sci Eng 20 (1): 9–10. https://doi.org/10.1109/MCSE.2018.011111120.\n\n\nECMA International. 2023. ECMAScript Language Specification. ECMA International. https://www.ecma-international.org/publications/standards/Ecma-262.htm.\n\n\nJanicki, Julia, Nitish Narula, Matt Ziegler, Benoit Guénard, and Evan P. Economo. 2016. “Visualizing and Interacting with Large-Volume Biodiversity Data Using Client–Server Web-Mapping Applications: The Design and Implementation of Antmaps.org.” Ecol Inform 32: 185–93. https://doi.org/10.1016/j.ecoinf.2016.02.006.\n\n\nKarnitis, Girts, and Guntis Arnicans. 2015. “Migration of Relational Database to Document-Oriented Database: Structure Denormalization and Data Transformation.” In 2015 7th International Conference on Computational Intelligence, Communication Systems and Networks, 113–18. https://doi.org/10.1109/CICSyN.2015.30.\n\n\nLin, Jimmy, and Kareem El Gebaly. 2016. “The Future of Big Data Is... JavaScript?” IEEE Internet Comput 20 (5): 82–88. https://doi.org/10.1109/mic.2016.109.\n\n\nMason, Robert Thomas. 2015. “NoSQL Databases and Data Modeling for a Document-Oriented NoSQL Database.” In InSITE Conference. Informing Science Institute. https://doi.org/10.28945/2245.\n\n\nMicrosoft Corporation. 2023. TypeScript. Microsoft. https://www.typescriptlang.org/.\n\n\nNode.js Contributors. 2023. Node.js. Node.js Foundation. https://nodejs.org/.\n\n\nOlivera, Harley Vera, Maristela Terto de Holanda, Valeria Guimarâes, Fernanda Hondo, and Wagner Boaventura. 2015. “Data Modeling for NoSQL Document-Oriented Databases.” In Symposium on Information Management and Big Data. https://api.semanticscholar.org/CorpusID:15589232.\n\n\nOnkov, Kolyo. 2011. “Object Oriented Modelling in Information Systems Based on Related Text Data.” In IFIP Adv Inf Commun Technol, 212–18. https://doi.org/10.1007/978-3-642-23960-1_26.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian Uszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016. “Ten Simple Rules for Taking Advantage of Git and GitHub.” Edited by Scott Markel. PLoS Comput 12 (7): e1004947. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nRai, Sawan, Ramesh Chandra Belwal, and Atul Gupta. 2022. “A Review on Source Code Documentation.” ACM Trans Intell Syst Technol 13 (5): 1–44. https://doi.org/10.1145/3519312.\n\n\nSequeira, R. A., R. L. Olson, and J. M. McKinion. 1997. “Implementing Generic, Object-Oriented Models in Biology.” Ecol Model 94 (1): 17–31. https://doi.org/10.1016/S0304-3800(96)01925-4.\n\n\nSpinellis, Diomidis. 2010. “Code Documentation.” IEEE Softw 27 (4): 18–19. https://doi.org/10.1109/ms.2010.95.\n\n\nTylman, Wojciech. 2016. “Computer Science and Philosophy: Did Plato Foresee Object-Oriented Programming?” Found Sci 23 (1): 159–72. https://doi.org/10.1007/s10699-016-9506-7.\n\n\nWarren, Alan, David J. Patterson, Micah Dunthorn, John C. Clamp, Undine E. M. Achilles-Day, Erna Aescht, Saleh A. Al-Farraj, et al. 2017. “Beyond the “Code”: A Guide to the Description and Documentation of Biodiversity in Ciliated Protists (Alveolata, Ciliophora).” J Eukaryot 64 (4): 539–54. https://doi.org/10.1111/jeu.12391.\n\n\nWegner, Peter. 1990. “Concepts and Paradigms of Object-Oriented Programming.” ACM SIGPLAN OOPS Messenger 1 (1): 7–87. https://doi.org/10.1145/382192.383004.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contexto</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introdução",
    "section": "",
    "text": "O esforço de descrever e catalogar organismos atravessa gerações, contribuindo de forma significativa para os alicerces do conhecimento biológico e da classificação dos seres vivos. Enraizada na literatura científica histórica, a prática de representar organismos por meio de descrições textuais atua como uma ponte entre as comunidades científicas do passado e do presente (Winston 1999; Morim and Lughadha 2015). Com o advento da era digital, métodos tradicionais se entrelaçam com as tecnologias contemporâneas (Morim and Lughadha 2015; Silva 2017).\nAtualmente, taxonomistas e sistematas recorrem frequentemente a editores de texto familiares, como o Microsoft (MS) Word, para elaborar meticulosamente suas descrições. Alguns profissionais também utilizam planilhas eletrônicas para estruturar dados (Sarkar, Schenk, and Norton 2008), porém os avanços tecnológicos têm aberto novas possibilidades para a documentação e organização da informação.\nNesse cenário em constante transformação, surgem oportunidades ainda pouco exploradas por meio de metodologias inovadoras. Apesar de as ferramentas digitais já terem agilizado diversas etapas da pesquisa, ainda existe um descompasso notável entre essas soluções contemporâneas e sua ampla adoção pela comunidade científica. É nesse contexto que esta proposta explora a relação sinérgica entre a Programação Orientada a Objetos (POO) e os Bancos de Dados Orientados a Documentos (DOD). Sob essa ótica, vislumbramos uma mudança de paradigma que pode impulsionar a pesquisa em biodiversidade rumo a uma era de maior eficiência, colaboração e inovação.\nO TypeScript (TS), uma extensão do JavaScript (JS, Ecma), representa uma escolha robusta para o desenvolvimento de sistemas complexos e bem organizados (Microsoft Corporation 2023). A combinação dos princípios da POO com o TS estabelece um ecossistema de desenvolvimento poderoso, que viabiliza a construção de bancos de dados no formato JavaScript Object Notation (JSON), além de permitir a aplicação de múltiplas camadas de validação de dados, resultando em uma base de dados altamente confiável.\nO formato JSON se destaca nos DODs pela sua capacidade de estruturar dados de maneira versátil (JSON Schema 2023). Diferente das planilhas eletrônicas, sua flexibilidade e hierarquia permitem acomodar diversos tipos de informação, sendo ideal para representar dados biológicos e anotações complexas. Essa estrutura é particularmente adequada para áreas como sistemática, química, ecologia, reprodução, genômica e proteômica, cujas informações frequentemente se organizam melhor em hierarquias aninhadas.\nEm paralelo, outra abordagem para a gestão de dados biológicos envolve o uso de ontologias, como a Gene Ontology (Ashburner et al. 2000; Gene Ontology Consortium et al. 2023) e a Plant Ontology (Cooper et al. 2012; Walls et al. 2012), que conectam conceitos biológicos por meio de vocabulários estruturados. No entanto, além de sua complexidade, essas representações demandam conhecimento técnico especializado, o que torna o uso do JSON uma alternativa mais acessível e atraente para um público mais amplo.\nO JSON se destaca na integração de bancos de dados de biodiversidade, oferecendo uma alternativa acessível. Enquanto as ontologias exigem especialização e dependem de software específico, o JSON capacita diretamente os biólogos, pois está no cerne da evolução da web, permitindo a democratização da pesquisa orientada por dados. Além disso, adotar a tecnologia GitHub favorece a colaboração ao possibilitar o compartilhamento contínuo de código, dados e insights (Perkel 2016). Simultaneamente, o Visual Studio Code (VS Code) gerencia habilmente o versionamento no GitHub. Esse conjunto de ferramentas combinado oferece um suporte significativo para pesquisadores em diversas áreas, facilitando empreendimentos multidisciplinares voltados para o avanço da nossa compreensão dos sistemas de biodiversidade e ecológicos.\nÀ medida que as capacidades na pesquisa sobre biodiversidade continuam a se expandir, o papel de mecanismos eficazes de integração de dados e ferramentas colaborativas torna-se cada vez mais crucial. Nesse contexto, a utilização do JSON para representar estruturas de dados em bancos de dados de biodiversidade, juntamente com o versionamento de código, não apenas preenche a lacuna entre estruturas de dados complexas e a comunidade científica mais ampla, mas também impulsiona soluções colaborativas no campo da pesquisa em biodiversidade.\nAqui, apresenta-se o TypeTaxonScript (TTS), um pacote JS/TS projetado para enriquecer as descrições taxonômicas e avançar na sistemática, ao mesmo tempo em que oferece uma estrutura de dados versátil capaz de acomodar informações ecológicas, reprodutivas e outras informações pertinentes sobre entidades biológicas. Defendemos a cessação do uso de editores de texto e planilhas, como MS Word e Excel, para descrições taxonômicas, devido à falta de processos robustos de validação durante a inserção de dados. Em vez disso, buscamos estabelecer um banco de dados resiliente e fácil de usar, garantindo a integridade dos dados, estabilidade e conformidade com práticas científicas padronizadas em descrições taxonômicas textuais, bem como matrizes de caracteres e interações.\n\n\n\n\nAshburner, Michael, Catherine A. Ball, Judith A. Blake, David Botstein, Heather Butler, J. Michael Cherry, Allan P. Davis, et al. 2000. “Gene Ontology: Tool for the Unification of Biology.” Nat Genet 25 (1): 25–29. https://doi.org/10.1038/75556.\n\n\nCooper, Laurel, Ramona L. Walls, Justin Elser, Maria A. Gandolfo, Dennis W. Stevenson, Barry Smith, Justin Preece, et al. 2012. “The Plant Ontology as a Tool for Comparative Plant Anatomy and Genomic Analyses.” Plant and Cell Physiology 54 (2): e1–1. https://doi.org/10.1093/pcp/pcs163.\n\n\nGene Ontology Consortium, Suzi A Aleksander, James Balhoff, Seth Carbon, J Michael Cherry, Harold J Drabkin, Dustin Ebert, et al. 2023. “The Gene Ontology Knowledgebase in 2023.” Genetics 224 (1). https://doi.org/10.1093/genetics/iyad031.\n\n\nJSON Schema. 2023. TypeScript. JSON Schema. https://www.json.org/json-pt.html.\n\n\nMicrosoft Corporation. 2023. TypeScript. Microsoft. https://www.typescriptlang.org/.\n\n\nMorim, Marli Pires, and Eimear M. Nic Lughadha. 2015. “Flora of Brazil Online: Can Brazils Botanists Achieve Their 2020 Vision?” Rodriguesia 66 (4): 1115–35. https://doi.org/10.1590/2175-7860201566412.\n\n\nPerkel, Jeffrey. 2016. “Democratic Databases: Science on GitHub.” Nature 538 (7623): 127–28. https://doi.org/10.1038/538127a.\n\n\nSarkar, Indra, Ryan Schenk, and Catherine N Norton. 2008. “Exploring Historical Trends Using Taxonomic Name Metadata.” BMC Evol Biol 8 (1): 144. https://doi.org/10.1186/1471-2148-8-144.\n\n\nSilva, Thiago Sanches Ranzani da. 2017. “Species Descriptions and Digital Environments: Alternatives for Accessibility of Morphological Data.” Rev Bras Entomol 61 (4): 277–81. https://doi.org/10.1016/j.rbe.2017.06.005.\n\n\nWalls, Ramona L., Balaji Athreya, Laurel Cooper, Justin Elser, Maria A. Gandolfo, Pankaj Jaiswal, Christopher J. Mungall, et al. 2012. “Ontologies as Integrative Tools for Plant Science.” American Journal of Botany 99 (8): 1263–75. https://doi.org/10.3732/ajb.1200222.\n\n\nWinston, Judith E. 1999. Describing Species: Practical Taxonomic Procedure for Biologists. Columbia University Press. http://www.jstor.org/stable/10.7312/wins06824.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "diretrizes.html",
    "href": "diretrizes.html",
    "title": "Diretrizes Padrão",
    "section": "",
    "text": "Convenções de Nomeação de Diretórios e Arquivos\nAs recomendações padrão servem como a base sobre a qual estabelecemos um ambiente de desenvolvimento coeso e estruturado. Ao seguir diligentemente essas normas e recomendações, estabelecemos as bases para um ecossistema de desenvolvimento que não apenas facilita a comunicação clara, a colaboração e práticas de codificação intuitivas, mas também se alinha aos domínios específicos do desenvolvimento em TypeScript (TS) e da gestão de dados de biodiversidade.\nNeste banco de dados, cada pedaço de informação deve ser organizado dentro de uma classe predefinida. Por exemplo, táxons, caracteres e fontes são representados como classes, cada uma armazenada em seu próprio arquivo .ts.\nA estrutura subjacente dos organismos, conforme delineada por taxonomistas e biólogos, é abstraída em uma árvore hierárquica de caracteres. Essa hierarquia é refletida em uma organização aninhada de diretórios, cada um contendo arquivos .ts. Os caracteres biológicos são encapsulados como classes.\nAs interconexões entre esses componentes são estabelecidas por meio dos mecanismos de importação e exportação de módulos.\nPor exemplo, em nosso banco de dados pré-construído, o gênero Mimosa L. é exemplificado por uma classe chamada Mimosa. Essa classe é acompanhada por um arquivo index.ts dentro do diretório Mimosa, oferecendo uma descrição abrangente da classe Mimosa. Da mesma forma, os atributos de uma folha são descritos dentro de um único arquivo index.ts no diretório correspondente.\nO processo de inserção de dados ocorre dentro do arquivo da espécie correspondente. Cada pedaço de informação é acomodado em um objeto que está alinhado a uma classe específica. Esses objetos são ajustados para interagir de forma fluida com suas respectivas classes, facilitando o armazenamento organizado dos dados no banco de dados.\nO primeiro passo consiste na instanciação de um objeto, seguido pelo preenchimento desse objeto com dados. Esse processo é fundamental para o acesso aos atributos e métodos do objeto associado à classe instanciada durante a compilação. Ele também permite a utilização de ferramentas de autocompletar. No código, uma nova instância de classe é criada da seguinte maneira: new NomeDaClasse().\nA modelagem de classes constitui uma tarefa fundamental dentro deste banco de dados. Ela envolve a definição de atributos e métodos. Embora exija esforço de codificação, essa prática é essencial para definir corretamente os tipos de dados aceitos por cada atributo (ou propriedade).\nAs fontes são representadas como instâncias da classe Sources e podem ser associadas a táxons ou caracteres específicos. A instanciação de fontes, no entanto, é realizada por meio da função extends no TypeScript. Essa decisão de design assegura que todas as classes no banco de dados possam incorporar uma fonte. A classe Sources funciona como um repositório para estabelecer conexões entre fontes bibliográficas — incluindo elementos como imagens ou outros formatos de dados — e as estruturas distintas dos organismos.\nNa raiz do projeto, encontramos os diretórios taxa e characters, que servem como repositórios para nosso banco de dados de gêneros e espécies, juntamente com suas características, representadas como uma árvore de caracteres.\nDentro do diretório characters, estabelecemos uma hierarquia aninhada de características relacionadas ao corpo do organismo, ou seja, a árvore de caracteres. Os caracteres são organizados em diretórios de acordo com sua hierarquia. Cada nível de hierarquia é encapsulado dentro de um diretório que leva o nome da classe, acompanhado de um arquivo index.ts.\nDentro deste arquivo index.ts, as classes utilizadas no seu escopo são tanto importadas quanto exportadas. No nível mais alto do diretório characters, encontramos os caracteres iniciais, como: stems (caules), leaves (folhas), trichomes (tricomas), prickles (acúleos), inflorescence (inflorescência), flowers (flores), fruits (frutos) e seeds (sementes).\nEm situações em que uma classe não depende de nenhuma outra, o nome do arquivo corresponde ao nome da classe, com a inicial maiúscula (por exemplo, Calyx.ts).\nDentro do diretório taxa, geramos subdiretórios nomeados de acordo com o epíteto genérico (por exemplo, Mimosa). Em cada um desses subdiretórios, é gerado um arquivo index.ts. Este arquivo é responsável por importar todas as classes de caracteres utilizadas para descrever os atributos de uma espécie pertencente ao respectivo gênero, contribuindo assim para a estrutura abrangente do nosso banco de dados.\nA organização sistemática é aprimorada detalhando cada espécie individual em um arquivo .ts distinto, localizado dentro do diretório correspondente ao gênero (por exemplo, ./Taxa/Mimosa/Mimosa_sevilhae.ts).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#árvore-de-caracteres",
    "href": "diretrizes.html#árvore-de-caracteres",
    "title": "Diretrizes Padrão",
    "section": "Árvore de Caracteres",
    "text": "Árvore de Caracteres\nUm banco de dados pré-construído, que contém a árvore de caracteres localizada no diretório characters, foi criado com base em pesquisas taxonômicas envolvendo o gênero Mimosa (Leguminosae, Caesalpinoideae) (Lucas Sá Barreto Jordão, Morim, and Baumgratz 2014; L. S. B. Jordão et al. 2017; Lucas S. B. Jordão, Morim, and Baumgratz 2018; Lucas Sá Barreto Jordão, Morim, and Baumgratz 2020).\nConforme a tradição, este banco de dados é inicialmente disponibilizado como a versão 1. Projetos futuros que sigam esses padrões podem usar este projeto como ponto de partida.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#descrição-do-gênero",
    "href": "diretrizes.html#descrição-do-gênero",
    "title": "Diretrizes Padrão",
    "section": "Descrição do Gênero",
    "text": "Descrição do Gênero\nDentro do diretório do gênero, o arquivo index.ts deve contemplar a importação de todos os caracteres localizados no primeiro nível da árvore de caracteres, declarando-os como atributos.\nObserve que os caracteres importados, como Stems e Leaf, são descritos em arquivos .ts dedicados dentro do diretório characters.\nAs linhas iniciais de código envolvem a importação de todos os caracteres definidos no primeiro nível da árvore de caracteres, juntamente com as classes de anotação. Em seguida, realiza-se a tarefa de criação da classe Mimosa.\nAo estender a classe Sources, permite-se associar uma fonte diretamente a uma espécie, diferenciando-se da associação de fontes a partes componentes, como caracteres na árvore de caracteres.\nÉ importante não esquecer de exportar a classe Mimosa.\nVeja o exemplo:\n// Importar caracteres\nimport {\n    Stems,\n    Leaf,\n    // outras classes do primeiro nível da árvore de caracteres\n} from '././characters/v1'\n\n// Importar classes de anotação\nimport { Sources } from '././characters/v1/Sources'\nimport { DescriptionAuthorship } from '././characters/v1/descriptionAuthorship'\n\nexport class Mimosa extends Sources {\n    specificEpithet: string\n    habit: 'tree' | 'shrub' | 'subshrub' | 'herb'\n    stems: Stems\n    leaf: Leaf\n    // outros atributos\n\n    constructor() {\n        super()\n    }\n}\nNo trecho de código fornecido, vale enfatizar que, conforme convencionalmente entendido, as linhas iniciadas com // são utilizadas exclusivamente para comentários dentro do código.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#descrição-de-espécies",
    "href": "diretrizes.html#descrição-de-espécies",
    "title": "Diretrizes Padrão",
    "section": "Descrição de espécies",
    "text": "Descrição de espécies\nInformações completas sobre uma espécie são cuidadosamente armazenadas em um arquivo .ts individual dentro do diretório correspondente ao seu gênero. Para descrever uma espécie, é necessário importar a classe do gênero Mimosa, importar as classes de caracteres, descrever a espécie utilizando os caracteres importados e, por fim, exportar a classe que representa essa espécie descrita. Essa estrutura também pode acomodar outros táxons infraespecíficos no banco de dados.\nA classe Mimosa funciona como o módulo central para a construção de todas as espécies de Mimosa, abrangendo a montagem da respectiva árvore de caracteres.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#importação-de-módulos",
    "href": "diretrizes.html#importação-de-módulos",
    "title": "Diretrizes Padrão",
    "section": "Importação de módulos",
    "text": "Importação de módulos\nAs primeiras linhas de código envolvem a importação de táxons, caracteres e classes de anotações. Para importar, utilize a seguinte sintaxe:\n// Importar gênero Mimosa\nimport { Mimosa } from '.'\n\n// Importar caracteres\nimport { Stems, Trichomes } from '././characters/v1'\nimport { Capitate } from '../../characters/v1/Trichomes'\nimport { CapitateFiliform } from '../../characters/v1/Trichomes/Capitate'\n\n// Importar classes de anotação\nimport { Source, DescriptionAuthorship } from '../../characters/v1'\nPara um processo de importação mais organizado, pode-se utilizar a técnica de desestruturação de objetos, permitindo a aquisição eficiente de classes de módulos interconectados.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#descrição",
    "href": "diretrizes.html#descrição",
    "title": "Diretrizes Padrão",
    "section": "Descrição",
    "text": "Descrição\nAo descrever uma espécie, recomenda-se criar uma constante utilizando a seguinte sintaxe: Mimosa_osmarii.\nEmbora variáveis em JavaScript geralmente usem camelCase, no desenvolvimento de um banco de dados de biodiversidade, sugere-se usar snake_case para variáveis que armazenam descrições. Além disso, para respeitar as regras de nomenclatura biológica, o nome do gênero deve ser capitalizado — ou seja, um Snake_case.\nUse notação de ponto (dot notation) para criar objetos dentro de objetos. Essa notação melhora a legibilidade do código e é considerada uma “açúcar sintático”.\nPara instanciar uma classe como um objeto na descrição, é necessário fazer a instanciação dentro de um objeto que aceite a classe instanciada. No exemplo abaixo, o código funciona porque a classe Mimosa possui o atributo specificEpithet, que recebe um valor do tipo primitivo string:\n// Descrição de Mimosa leptantha\nconst Mimosa_leptantha = new Mimosa()\nMimosa_leptantha.specificEpithet = 'leptantha'\nÉ importante instanciar cada classe aninhada antes de declarar um atributo. Para descrever adequadamente a presença ou ausência de características específicas, é necessário seguir convenções precisas.\nOs termos is e are servem como sinônimos para indicar a presença ou ausência da característica com base em nomes de objetos singulares ou plurais. Recomenda-se indicar a presença ou ausência imediatamente após a instanciação da nova classe:\nMimosa_leptantha.stems = new Stems()\nMimosa_leptantha.stems.trichomes = new Trichomes()\nMimosa_leptantha.stems.trichomes.capitate = new Capitate()\nMimosa_leptantha.stems.trichomes.capitate.filiform = new CapitateFiliform()\nMimosa_leptantha.stems.trichomes.capitate.filiform.are = 'present'\nCom base no exemplo acima, estamos afirmando a presença de tricomas capitado-filiformes nos caules de Mimosa leptantha Benth., no banco de dados.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#anotações",
    "href": "diretrizes.html#anotações",
    "title": "Diretrizes Padrão",
    "section": "Anotações",
    "text": "Anotações\nRecomenda-se fortemente que as anotações sejam declaradas por último — mas, claro, antes da exportação da descrição da espécie.\nApós a descrição, é importante adicionar o autor da descrição utilizando o atributo descriptionAuthorship, que recebe o nome e uma data em timestamp Unix (contagem de segundos desde 00:00:00 UTC de 01 de janeiro de 1970).\n// Autoria da descrição\nMimosa_leptantha.descriptionAuthorship = new DescriptionAuthorship()\nMimosa_leptantha.descriptionAuthorship.addAuthor({\n  name: 'June Doe',\n  date: 1692107172\n})\nA classe Source foi modelada para armazenar citações no estilo bibtex, mas acrescentamos o atributo obtainingMethod, que pode ter um dos seguintes valores: nakedEyes, stereoscope, opticalMicroscope, scanningElectronMicroscope, tranmissionElectronMicroscope, photo, drawing.\nPara adicionar uma fonte e vincular a publicação à parte da planta, primeiro precisamos criar uma constante que armazenará a classe Source, e então usar o método addSource():\n// Fontes\n\n/// Tricomas\nconst source1 = new Source()\nsource1.sourceType = 'article'\nsource1.authorship = 'Jordão, L.S.B. & Morim, M.P. & Baumgratz, J.F.A.'\nsource1.year = '2020'\nsource1.title = 'Trichomes in *Mimosa* (Leguminosae): Towards a characterization and a terminology standardization'\nsource1.journal = 'Flora'\nsource1.number = '272'\nsource1.pages = '151702'\nsource1.figure = '9I, J, K, L'\nsource1.obtainingMethod = 'scanningElectronMicroscope'\n\nMimosa_leptantha.stems.trichomes.capitate.filiform.addSource(source1)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#exportação-de-módulos",
    "href": "diretrizes.html#exportação-de-módulos",
    "title": "Diretrizes Padrão",
    "section": "Exportação de módulos",
    "text": "Exportação de módulos\nEmbora existam diversas formas de exportar módulos em JS e TS, uma prática padrão é garantir que a espécie esteja completamente descrita, e que a última linha do arquivo seja a exportação da variável.\nEssa abordagem melhora a legibilidade e a manutenção do código:\n// Exportar Mimosa leptantha\nexport { Mimosa_leptantha }",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#modelagem-de-classes-de-caracteres",
    "href": "diretrizes.html#modelagem-de-classes-de-caracteres",
    "title": "Diretrizes Padrão",
    "section": "Modelagem de classes de caracteres",
    "text": "Modelagem de classes de caracteres\nEm TypeScript, as classes de caracteres são estruturadas como classes propriamente ditas. O nome da classe segue a convenção PascalCase e é definido usando a sintaxe: class Fruit {}.\nAo importar uma classe para a descrição de caracteres, é crucial evitar nomes duplicados. Assim, torna-se necessário lidar com a ocorrência de nomes de personagens repetidos.\nNos casos em que uma estrutura tem nomes com hífens, como ‘setiform-capitate’ ou ‘stellate-lepidote’, o nome da classe começa com a primeira palavra. Nesses casos, ela é transformada em SetiformCapitate e StellateLepidote.\nPara classes com nomes genéricos como ‘abaxial’, ‘adaxial’ ou ‘margin’, a prática recomendada é começar com o nome comum seguido da estrutura anatômica correspondente. Por exemplo, AbaxialLeaflet e MarginBracteole.\nOs nomes de atributos dentro das classes seguem o padrão camelCase e são definidos com a sintaxe: numberOfPairs: number. Isso reflete os pares chave-valor característicos de objetos JSON.\nOs atributos podem incluir diferentes tipos de dados, como strings e números. Veja alguns exemplos ilustrativos:\nDefinindo um atributo specificEpithet da classe Mimosa que armazena um valor do tipo string:\nclass Mimosa {\n    specificEpithet: string\n}\nDefinindo um atributo numberOfPairs para a classe Pinnae, com valor do tipo number:\nclass Pinnae {\n    numberOfPairs: number\n}\nApresentando tipos alternativos para um atributo usando o símbolo de barra vertical (|):\nclass Replum {\n    shape: 'straight' | 'undulate'\n}\nPermitindo versatilidade para um caráter multivalorado com (valor | valor | valor)[]:\nclass Leaflet {\n    shape:\n        'linear' |\n        'lanceolate' |\n        'elliptic' |\n        'oval' |\n        (\n            'linear' |\n            'lanceolate' |\n            'elliptic' |\n            'oval'\n        )[]\n}\nApós descrever os atributos da classe, é necessário invocar a função constructor() {} para instanciar cada atributo assim que o módulo for importado em outro local.\nOs métodos da classe são listados após o construtor. Na hora de nomear métodos para caracteres e documentar sua funcionalidade, é essencial manter uma abordagem consistente e informativa. Optamos por evitar o uso de funções nativas para favorecer a intuitividade. Os nomes dos métodos seguem um formato padronizado, como o uso de add para métodos como addSource. Ao especificar dados, utiliza-se set, como em setLength, para garantir uniformidade e clareza.\nNeste código, foi desenvolvido um conjunto de métodos para gerenciar medidas de diferentes dimensões — especificamente comprimento, altura e largura. Esses métodos permitem definir e manipular precisamente essas medidas para diversos objetos. Aceitando valores numéricos, as funções setLength, setHeight e setWidth definem individualmente as dimensões principais. Além disso, as funções _setLengthMinMax, setHeightMinMax e setWidthMinMax permitem especificar intervalos, considerando valores mínimos e máximos. As funções setLengthRarelyMin e setLengthRarelyMax permitem a entrada de valores mínimos e máximos usados ocasionalmente — o mesmo vale para altura e largura. Esses métodos, em conjunto, contribuem para um framework abrangente de gerenciamento de atributos dimensionais, conforme condições e restrições específicas que podem ser verificadas em tempo de execução.\nPor fim, durante a exportação, se uma classe possuir atributos que são outras classes com seus próprios atributos — formando um padrão aninhado — é necessário exportar não apenas a classe criada, mas também cada atributo importado. Isso garante a coerência de importações e exportações entre módulos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#documentação-em-typescript",
    "href": "diretrizes.html#documentação-em-typescript",
    "title": "Diretrizes Padrão",
    "section": "Documentação em TypeScript",
    "text": "Documentação em TypeScript\nEste documento fornece diretrizes para documentar descrições de táxons, cobrindo tanto tags obrigatórias quanto opcionais. Campos obrigatórios incluem o nome do autor e a data, os quais atribuem a devida autoria à descrição.\nO processo de documentação utiliza TSDoc. A primeira linha deve servir como título da classe. Para ampliar as descrições de classes, pode-se usar a tag @remarks. Vários elementos de marcação Markdown funcionam dentro do TSDoc, e tópicos podem ser adicionados iniciando a linha com um hífen -.\nUma tag essencial é @source, que permite a adição de referências bibliográficas. Dentro da tag @source, a notação Markdown para links HTML, como [rótulo](link), pode ser usada de forma eficaz. Assim, URLs com DOI podem ser citadas para estabelecer links diretos no banco de dados.\n\nDocumentação de Táxon\nAo documentar os atributos de um gênero, recomenda-se incluir o nome do gênero na primeira linha de cada bloco TSDoc.\nAntes da seção constructor() {}, é aconselhável declarar “Creates an instance of [class]”. Essa prática reforça os princípios da POO. Nosso banco de dados contém exclusivamente uma classe de táxon, Mimosa, que representa um gênero. Para documentar essa classe, é utilizada uma sintaxe especializada:\nexport class Mimosa extends Sources {\n    /**\n     * Espécies de *Mimosa*\n     */\n    specificEpithet: string\n\n    /**\n     * Hábito de *Mimosa*\n     */\n    habit: 'tree' | 'shrub' | 'subshrub' | 'herb'\n\n    /**\n     * Caule de *Mimosa*.\n     */\n    stems: Stems\n\n    /**\n     * Acúleos de *Mimosa*.\n     */\n    prickles: Prickles\n\n    /**\n     * Folha de *Mimosa*: bipinada\n     */\n    leaf: Leaf\n\n    /**\n     * Cria uma instância da espécie *Mimosa*.\n     */\n    constructor() {\n        super()\n    }\n}\nPara a descrição do gênero, a documentação dos principais caracteres pode ser armazenada assim:\nexport class Mimosa extends Sources {\n    /**\n     * Tricomas de *Mimosa*.\n     *\n     * @remarks\n     * Os tricomas em *Mimosa* podem ser classificados nos seguintes tipos:\n     * - **filiforme**\n     * - **setiforme**\n     * - **estrelado**\n     * - **dendrítico**\n     * - **prostrado**\n     * - **fasciculado**\n     * - **verruciforme**\n     * - **lepidoto**\n     * - **granular**\n     * - **capitado-filiforme**\n     * - **capitado-setiforme**\n     *\n     * @source [Jordão et al. (2020)](https://doi.org/10.1016/j.flora.2020.151702)\n     * @source [Santos-Silva et al. (2013)](https://doi.org/10.11646/phytotaxa.119.1.1)\n     */\n    trichomes: Trichomes\n\n    /**\n     * Cria uma instância da espécie *Mimosa*.\n     */\n    constructor() {\n        super()\n    }\n}\n\n\nDocumentação de Caracteres\nPara documentar uma classe de caráter, recomenda-se incluir o nome da classe-pai em cada atributo. Dentro de @remarks, considere listar os tipos de atributo como tópicos separados e destacá-los com negrito. Após o :, forneça uma explicação descritiva. Essa abordagem garante clareza e descrição completa dos tipos.\nComo ilustrado no exemplo abaixo, o nome do atributo é reiterado e vinculado à classe associada. Essa prática garante coesão na montagem dos objetos dentro da árvore de caracteres:\nexport class Epicarp extends Sources {\n    /**\n     * Tipo de epicarpo.\n     */\n    type: 'monospermic' | 'undivided'\n\n    /**\n     * Margem do epicarpo.\n     *\n     * @remarks\n     * A margem do epicarpo pode ser: 'reta' ou 'ondulada':\n     * - **straight**: A margem do epicarpo é reta e não ondulada.\n     * - **undulate**: A margem do epicarpo é ondulada e não reta.\n     */\n    margin: 'straight' | 'undulate'\n\n    /**\n     * Cria uma instância de Epicarp.\n     */\n    constructor() {\n        super()\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#exportação-do-banco-de-dados",
    "href": "diretrizes.html#exportação-do-banco-de-dados",
    "title": "Diretrizes Padrão",
    "section": "Exportação do Banco de Dados",
    "text": "Exportação do Banco de Dados\nPara exportar o banco de dados em formato JSON, apresentamos um método que envolve a recuperação de todos os arquivos de espécies do diretório do gênero e sua organização em um array de objetos. Adicionalmente, implementamos uma camada de validação que verifica e remove duplicatas dentro desses arrays, mas outras validações podem ser implementadas.\nA classe Sources, representada como um array de objetos, pode estar presente em todas as profundidades dentro da descrição dos táxons e da árvore de caracteres. Para facilitar a recuperação e consulta de dados, especialmente dados relacionados às fontes, incluímos um método para exportar um banco de dados de fontes. Esse banco permite recuperar informações posicionais (como índice e caminho JSON) dentro do banco de dados principal. Essas informações são particularmente úteis para localizar exatamente o caráter associado a uma fonte específica.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "diretrizes.html#versionamento-com-git",
    "href": "diretrizes.html#versionamento-com-git",
    "title": "Diretrizes Padrão",
    "section": "Versionamento com Git",
    "text": "Versionamento com Git\nNo contexto do versionamento com Git, as mensagens de commit podem seguir uma semântica padronizada para garantir uma comunicação clara — e até permitir certa automação dentro do sistema Git.\n\nAdicionando um novo táxon\nEm cenários onde uma nova entrada taxonômica é inserida no banco de dados, o formato sugerido para a mensagem de commit é o seguinte:\nfeat(taxon): Add taxon \"Mimosa osmarii\"\n\nAdd taxon to the database.\nEsse formato resume de forma concisa a essência do commit ao encapsular a ação (“Add”), a entidade afetada (“taxon”) e o nome específico da entidade (“Mimosa osmarii”). A descrição complementar fornece mais contexto, garantindo que outros desenvolvedores compreendam a natureza da adição.\n\n\nAtualizando dados de um táxon\nQuando atualizações são feitas nos dados de um táxon já existente, a estrutura da mensagem de commit segue este padrão:\nfeat(taxon): Update taxon \"Mimosa osmarii\"\n\nUpdate data of taxon in the database.\nEssa estrutura comunica de forma clara a alteração feita (“Update taxon”), especifica o táxon modificado (“Mimosa osmarii”) e fornece uma breve descrição da modificação.\n\n\nAdicionando um novo caráter\nA introdução de novos caracteres no banco de dados segue uma lógica semântica semelhante:\nfeat(character): Add character \"Leaf\", \"Petiole\"\n\nAdd character(s) to the database.\nO identificador “feat(character)” indica a adição de um caráter, seguido pelos nomes dos caracteres. A descrição associada esclarece a ação executada.\n\n\nAtualizando um caráter\nA atualização de informações de caracteres existentes também segue essa estrutura:\nfeat(character): Update character \"Leaf\", \"Petiole\"\n\nUpdate character(s) in the database.\nA consistência na estrutura permite uma compreensão rápida da alteração (“Update character”), identifica os caracteres modificados (“Leaf” e “Petiole”) e resume brevemente a atualização realizada.\n\n\n\n\nJordão, L. S. B., M. P. Morim, J. F. A. Baumgratz, and M. F. Simon. 2017. “A New Species of Mimosa (Leguminosae) Endemic to the Brazilian Cerrado.” Phytotaxa 312 (2): 237. https://doi.org/10.11646/phytotaxa.312.2.6.\n\n\nJordão, Lucas S. B., Marli P. Morim, and José Fernando A. Baumgratz. 2018. “Toward a Census of Mimosa (Leguminosae) in the Atlantic Domain, Southeastern Brazil.” Syst Bot 43 (1): 162–97. https://doi.org/10.1600/036364418x696905.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando A. Baumgratz. 2020. “Trichomes in Mimosa (Leguminosae): Towards a Characterization and a Terminology Standardization.” Flora 272 (November): 151702. https://doi.org/10.1016/j.flora.2020.151702.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando Andrade Baumgratz. 2014. “A New Species of Mimosa (Leguminosae) from Brazil.” Phytotaxa 184 (3): 131. https://doi.org/10.11646/phytotaxa.184.3.2.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Diretrizes Padrão</span>"
    ]
  },
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "Instalar o Node.js\nAntes de começar, certifique-se de que o Node.js está instalado no seu sistema. O Node.js é essencial para executar aplicações JavaScript na sua máquina. Você pode baixá-lo e instalá-lo no site oficial do Node.js: https://nodejs.org/.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#instalar-o-visual-studio-code",
    "href": "tutorial.html#instalar-o-visual-studio-code",
    "title": "Tutorial",
    "section": "Instalar o Visual Studio Code",
    "text": "Instalar o Visual Studio Code\nO Visual Studio Code (VS Code) é um editor de código versátil que oferece uma interface amigável e uma variedade de extensões para melhorar o desenvolvimento. Baixe e instale o VS Code pelo site oficial: https://code.visualstudio.com/.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#clonar-o-repositório-do-github-no-vs-code",
    "href": "tutorial.html#clonar-o-repositório-do-github-no-vs-code",
    "title": "Tutorial",
    "section": "Clonar o repositório do GitHub no VS Code",
    "text": "Clonar o repositório do GitHub no VS Code\nPara clonar o repositório do projeto Mimosa para o TTS a partir do GitHub, siga estes passos:\n\nNo VS Code, abra o Command Palette com Ctrl + Shift + P (Windows/Linux) ou Cmd + Shift + P (macOS).\nDigite Git: Clone e selecione a opção que aparecer.\nUm campo de texto será exibido no topo da janela. Insira a URL do repositório: https://github.com/lsbjordao/TTS-Mimosa\nEscolha um diretório local onde deseja salvar o repositório.\n\nRecomendamos fortemente evitar espaços ou caracteres incomuns no caminho escolhido para evitar problemas ao abrir arquivos clicando no terminal do IDE.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#abrir-o-diretório-do-projeto-tts-no-vs-code",
    "href": "tutorial.html#abrir-o-diretório-do-projeto-tts-no-vs-code",
    "title": "Tutorial",
    "section": "Abrir o diretório do projeto TTS no VS Code",
    "text": "Abrir o diretório do projeto TTS no VS Code\n\nClique em Arquivo no menu superior.\nSelecione Abrir Pasta.\nNavegue até o local onde está o diretório do projeto TTS (ex: TTS-Mimosa).\nSelecione o diretório e clique em Abrir.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#instalar-o-pacote-tts",
    "href": "tutorial.html#instalar-o-pacote-tts",
    "title": "Tutorial",
    "section": "Instalar o pacote TTS",
    "text": "Instalar o pacote TTS\nNo VS Code, abra o terminal e execute o comando na raiz do projeto, onde está o package.json:\n\nVá ao menu superior e clique em Terminal → Novo Terminal.\nDigite e execute:\n\nnpm install -g type-taxon-script\nInstale com a flag -g para evitar que dependências sejam criadas dentro do diretório do projeto. Caso contrário, será gerada uma pasta ./node_modules e um arquivo package.json localmente.\nPara verificar se a instalação foi bem-sucedida, use:\ntts --version\nPara ver a ajuda com todos os comandos disponíveis:\ntts --help",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#desinstalar-o-pacote-tts",
    "href": "tutorial.html#desinstalar-o-pacote-tts",
    "title": "Tutorial",
    "section": "Desinstalar o pacote TTS",
    "text": "Desinstalar o pacote TTS\nPara desinstalar o pacote TTS, use:\nnpm uninstall -g @lsbjordao/type-taxon-script",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#inicializar-um-projeto-tts",
    "href": "tutorial.html#inicializar-um-projeto-tts",
    "title": "Tutorial",
    "section": "Inicializar um projeto TTS",
    "text": "Inicializar um projeto TTS\nPara iniciar um projeto TTS:\ntts init\nEsse comando verifica se há um projeto existente e cria os diretórios obrigatórios ./input e ./output, mas somente se as pastas characters e taxon já existirem.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#descrever-um-novo-táxon",
    "href": "tutorial.html#descrever-um-novo-táxon",
    "title": "Tutorial",
    "section": "Descrever um novo táxon",
    "text": "Descrever um novo táxon\nPara criar um novo arquivo .ts com a hierarquia completa de caracteres, use:\ntts new --genus Mimosa --species epithet\nUm arquivo chamado Mimosa_epithet.ts será gerado no diretório ./output. Antes de editar, mova esse arquivo para a pasta ./taxon, pois o script só funciona corretamente dentro dela. Fora dessa pasta, ocorrerão erros de dependência.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#importar-de-um-arquivo-.csv",
    "href": "tutorial.html#importar-de-um-arquivo-.csv",
    "title": "Tutorial",
    "section": "Importar de um arquivo .csv",
    "text": "Importar de um arquivo .csv\nTambém é possível importar dados de múltiplos táxons a partir de um .csv, com o comando:\ntts import --genus Mimosa\nO arquivo .csv deve:\n\nUsar ; como separador e \" como delimitador de texto\nTer pelo menos a coluna specificEpithet\nUsar o caminho JSON completo como nome de cada coluna\n\nPara indicar múltiplos estados em uma célula, use:\n['4-merous', '5-merous']\nPara características que são objetos-chave (ex: tipos de inflorescência), crie colunas como inflorescence.capitate e insira yes na célula correspondente ao táxon.\nOs arquivos .ts gerados serão salvos em ./output, mas devem ser movidos manualmente para ./taxon para funcionar corretamente.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#documentação",
    "href": "tutorial.html#documentação",
    "title": "Tutorial",
    "section": "Documentação",
    "text": "Documentação\nTodos os elementos do código têm metadados (Figure 4.1). Ao passar o cursor sobre eles no VS Code, as informações aparecem em um popup.\n\n\n\n\n\n\nFigure 4.1: Ao passar o cursor sobre um texto em uma IDE como o VS Code, um pop-up exibirá seus metadados.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#edição-de-táxons",
    "href": "tutorial.html#edição-de-táxons",
    "title": "Tutorial",
    "section": "Edição de táxons",
    "text": "Edição de táxons\nPara editar um arquivo .ts de espécie:\n\nDigite ' ou \" após o sinal = para ver as opções de atributos (Figure 4.2)\nPressione Enter para confirmar\nO VS Code oferece autocompletar com os estados válidos de cada propriedade\n\n\n\n\n\n\n\nFigure 4.2: O VS Code auxilia com sua ferramenta de autocompletar, exibindo todos os estados permitidos para cada propriedade.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#referência-cruzada",
    "href": "tutorial.html#referência-cruzada",
    "title": "Tutorial",
    "section": "Referência cruzada",
    "text": "Referência cruzada\n\nAo segurar Ctrl e clicar em uma classe, o arquivo com a descrição da classe é aberto automaticamente.\nTambém é possível ver onde cada classe é utilizada em outras partes do código.\nIsso ajuda a navegar rapidamente pela hierarquia de caracteres.\n\nAlém disso, temos a capacidade de rastrear onde uma determinada classe está sendo utilizada. Por exemplo, ao procurar por ocorrências do uso de uma classe de caractere, podemos simplesmente inspecionar o nome da classe. Como ilustrado no exemplo, uma galha (Gall) é mencionada na descrição de Mimosa gemmulata Barneby, e ao clicar sobre ela, podemos abrir rapidamente seu respectivo arquivo (Figure 4.3).\n\n\n\n\n\n\nFigure 4.3: O cruzamento de dependências entre módulos ajuda a identificar rapidamente onde um caractere é invocado, enquanto o VS Code rastreia e exibe com eficiência o uso de cada caractere da árvore de caracteres.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#edição-multilinha",
    "href": "tutorial.html#edição-multilinha",
    "title": "Tutorial",
    "section": "Edição multilinha",
    "text": "Edição multilinha\nUse Ctrl + Shift + L para edição em múltiplas linhas. Pressione Esc para encerrar.\n\n\n\n\n\n\nFigure 4.4: Editar código pode ser desafiador às vezes, mas o VS Code oferece ferramentas úteis para tornar o processo mais ágil, como a edição em múltiplas linhas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#formatação-automática-de-código",
    "href": "tutorial.html#formatação-automática-de-código",
    "title": "Tutorial",
    "section": "Formatação automática de código",
    "text": "Formatação automática de código\nClique com o botão direito em qualquer lugar do código e escolha Formatar Documento. Isso ajusta automaticamente indentação, espaçamento e estilo.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#controle-de-versão-com-git",
    "href": "tutorial.html#controle-de-versão-com-git",
    "title": "Tutorial",
    "section": "Controle de versão com Git",
    "text": "Controle de versão com Git\nNo VS Code, um clique rápido em um arquivo listado no painel do Git permite inspecionar instantaneamente as alterações no código (Figure 4.5). Ao abrir o arquivo, uma tela dividida é exibida, destacando as alterações em verde (edições) e vermelho (revisões), em comparação com a versão anterior do código. Essa funcionalidade facilita o processo de revisão, oferecendo uma maneira intuitiva e eficiente de acompanhar as modificações no ambiente de desenvolvimento.\n\n\n\n\n\n\nFigure 4.5: O VS Code se integra perfeitamente ao GitHub, tornando-se amigável mesmo para usuários com pouca experiência, exigindo apenas uma curva de aprendizado leve.\n\n\n\nO VS Code oferece uma variedade de recursos e extensões para facilitar a resolução de conflitos. Isso inclui ferramentas interativas de mesclagem, comparação de arquivos lado a lado e até suporte nativo a mesclagem em três vias. Podemos gerenciar o controle de versão com Git por meio de simples cliques de botão.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#exportar-banco-de-dados-.json",
    "href": "tutorial.html#exportar-banco-de-dados-.json",
    "title": "Tutorial",
    "section": "Exportar banco de dados .json",
    "text": "Exportar banco de dados .json\nPara exportar todos os táxons dentro de ./taxon/Mimosa:\ntts export --genus Mimosa\n\nPara exportar apenas alguns táxons listados em ./input/taxonToImport.csv, use:\ntts export --genus Mimosa --load csv\nO arquivo gerado será salvo em ./output/ com o nome ${genus}DB.json.\nErros podem ocorrer em dois momentos:\n\nDurante a compilação (TS): como propriedades incorretas (ex: ractole em vez de bracteole)\nDurante a execução (JS): como regras de negócio violadas (ex: min = 5 e max = 3)\n\nSobre os erros de compilação, por exemplo, dois problemas foram encontrados nos arquivos Mimosa_test.ts e Mimosa_test2.ts durante a tentativa de exportar o banco de dados de Mimosa (Figure 4.6). No script Mimosa_test.ts, foi detectada uma propriedade não declarada para a face adaxial do folíolo. Já no script Mimosa_test2.ts, a classe ractole foi listada como uma propriedade da flor, mas a mensagem de erro sugere a correção para bracteole. Veja abaixo:\n\n\n\n\n\n\nFigure 4.6: Erros ocorridos durante o processo de transpilação de arquivos .ts para .js decorrem de violações de regras de sintaxe estabelecidas ou inconsistências de tipos no código TypeScript. Essas violações incluem erros de sintaxe, tipagem incorreta ou uso inadequado de recursos da linguagem TypeScript. Cada mensagem de erro fornece detalhes específicos que ajudam na identificação e resolução do problema encontrado.\n\n\n\nAlém disso, erros podem ser capturados durante a fase de execução. No exemplo abaixo, o comprimento de uma estípula foi definido com valor mínimo igual a 5 e máximo igual a 3, utilizando o método .setHeightMinMax() (Figure 4.7). Esse tipo de erro não é detectado na compilação, pois o tipo (number) está correto, mas, durante a execução, uma mensagem no terminal informa que “a altura mínima deve ser menor que a altura máxima”. Veja abaixo:\n\n\n\n\n\n\nFigure 4.7: Erros derivados da compilação de arquivos .js evitam erros em tempo de execução, aplicando as regras de negócio definidas em cada método de classe. Neste exemplo, apesar de não haver violação de tipo de dado — já que a função aceita dois números —, existe uma regra de negócio para validar se o valor mínimo é realmente menor que o valor máximo. Esse processo evita erros de inserção de dados, garantindo conformidade com as regras definidas.\n\n\n\n\nConjunto de dados de fontes\nPodemos criar um conjunto de dados consolidado que reúne todas as fontes em uma estrutura JSON achatada, facilitando o acesso por meio de consultas. Para gerar um banco de dados contendo apenas as fontes relacionadas aos táxons, execute o seguinte comando:\ntts exportSources --genus Mimosa\nEste conjunto de dados inclui um índice que se relaciona com o banco de dados principal e fornece o caminho completo da chave onde cada fonte está localizada:\n[{\n    index: 7,\n    path: 'flower.corolla.trichomes.stellate.lepidote',\n    source: {\n      sourceType: 'article',\n      authorship: 'Jordão, L.S.B. & Morim, M.P. & Baumgratz, J.F.A.',\n      year: 2020,\n      title: 'Trichomes in *Mimosa* (Leguminosae): Towards a characterization and a terminology standardization',\n      journal: 'Flora',\n      number: 272,\n      pages: 151702,\n      figure: '4I',\n      obtainingMethod: 'scanningElectronMicroscope'\n    }\n}]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#exportar-banco-de-dados-.csv",
    "href": "tutorial.html#exportar-banco-de-dados-.csv",
    "title": "Tutorial",
    "section": "Exportar banco de dados .csv",
    "text": "Exportar banco de dados .csv\nNo TTS, existe um método conveniente para exportar um banco de dados convertido em JSON para o formato CSV usando o comando exportToCsv. Semelhante ao comando export, ele gera uma saída em CSV. De fato, abrir um arquivo CSV em uma planilha é bastante útil. No entanto, é importante observar que essa conversão implica em perda de estrutura dos dados. A primeira linha do CSV será composta por todos os caminhos JSON, preservando a hierarquia aninhada, mas arrays de elementos serão tratados como strings com a mesma sintaxe JSON. Para transformações mais avançadas, é possível explorar métodos adicionais no Json2csv.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#navegando-no-banco-de-dados",
    "href": "tutorial.html#navegando-no-banco-de-dados",
    "title": "Tutorial",
    "section": "Navegando no banco de dados",
    "text": "Navegando no banco de dados\nUtilizando a extensão JSON Grid Viewer (https://github.com/dutchigor/json-grid-viewer), disponível no Visual Studio Marketplace (https://marketplace.visualstudio.com/), podemos explorar facilmente a estrutura detalhada de configurações JSON (Figure 4.8).\n\n\n\n\n\n\nFigure 4.8: O pacote json-grid-viewer é altamente útil, pois fornece uma visualização amigável de arquivos JSON. Seu foco principal é visualizar objetos e arrays, que são componentes típicos de uma estrutura JSON.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "tutorial.html#métodos-de-consulta",
    "href": "tutorial.html#métodos-de-consulta",
    "title": "Tutorial",
    "section": "Métodos de consulta",
    "text": "Métodos de consulta\nAs técnicas de consulta de dados abrangem uma variedade de métodos adaptados a diferentes necessidades. As consultas básicas baseiam-se em pares chave-valor para recuperação precisa de dados, enquanto as consultas por intervalo são ideais para dados numéricos ou baseados em datas, permitindo a extração dentro de faixas de valores definidas.\nOutro tipo de consulta envolve a abordagem de agregação, que permite manipulação avançada de dados, como agrupamento e filtragem encadeada no banco de dados. Isso é possível porque o resultado de uma consulta sempre retorna o documento completo dentro do banco, permitindo encadear novas consultas para realizar múltiplas agregações.\n\nConsulta por caminho de caractere\nUm aspecto essencial das consultas é identificar um caminho JSON que represente propriedades aninhadas em um array de documentos em um banco de dados JSON. Neste caso, nosso objetivo é navegar pela árvore de caracteres para recuperar propriedades dos táxons.\nVamos definir “propriedade” como um caminho de chaves dentro da árvore de caracteres. Quando queremos recuperar uma propriedade do banco, buscamos seu caminho JSON correspondente, como trichomes.stellate. Esta busca retorna os índices dos documentos onde a propriedade foi encontrada e os caminhos em que ela se localiza, usando o comando findProperty:\ntts findProperty --property trichomes.stellate --genus Mimosa\nO resultado deve ser similar a:\n[\n  { specificEpithet: 'furfuraceae', index: 5, paths: [ 'flower.corolla' ] },\n  { specificEpithet: 'myuros', index: 6, paths: [ 'stems' ] },\n  {\n    specificEpithet: 'schomburgkii',\n    index: 7,\n    paths: [ \n        'leaf.bipinnate.pinnae.leaflet.abaxial',\n        'flower.corolla' \n    ]\n  }\n]\nNo exemplo acima, tricomas estrelados foram identificados na corola de M. furfuraceae, nos caules de M. myuros e tanto na face abaxial do folíolo quanto na corola de M. schomburgkii.\n\n\nConsulta flexível chave-valor\nOutra abordagem de consulta é a chave-valor flexível. Esse método permite buscas dentro de caminhos JSON usando valores específicos que atendam a condições definidas.\nPara iniciar consultas em uma exportação do projeto TTS, execute os procedimentos fora do diretório do projeto. Comece criando um diretório separado (ex: flex-json-searches) e abra-o em um IDE como o VS Code.\nPara realizar consultas JSON flexíveis, instale os módulos flex-json-searcher (https://github.com/vicentecalfo/flex-json-searcher) e fs. No terminal, execute:\nnpm install fs\nnpm install flex-json-searcher\nDepois, crie um arquivo script.js e insira o seguinte código:\n// script.js\nconst fs = require('fs')\nconst { FJS } = require('flex-json-searcher')\n\nconst filePath = './output/MimosaDB.json'\n\nfs.readFile(filePath, 'utf8', async (err, data) =&gt; {\n  if (err) {\n    console.error('Erro ao ler o arquivo:', err)\n    return\n  }\n  \n  try {\n    const mimosaDB = JSON.parse(data)\n    const fjs = new FJS(mimosaDB)\n    const query = { 'flower.merism': { $eq: \"3-merous\" } }\n\n    const output = await fjs.search(query)\n    const specificEpithets = output.result.map(item =&gt; item.specificEpithet)\n    console.log('Espécies encontradas:', specificEpithets)\n  } catch (error) {\n    console.error('Erro durante o processamento:', error)\n  }\n})\nExecute com:\nnode script\nResultado esperado:\nEspécies encontradas: [\n  'afranioi',\n  'caesalpiniifolia',\n  'ceratonia var pseudo-obovata',\n  'robsonii'\n]\nDurante a busca, *. pode ser usado para localizar caminhos JSON específicos associados a condições.\n\n\nConsulta por intervalo\nA consulta por intervalo permite buscar dados dentro de faixas específicas de valores, como datas, valores numéricos ou outros atributos.\nInstale os módulos:\nnpm install fs\nnpm install flex-json-searcher\nCrie o arquivo script2.js:\n// script2.js\nconst fs = require('fs')\nconst { FJS } = require('flex-json-searcher')\n\nconst filePath = './output/MimosaDB.json'\n\nfs.readFile(filePath, 'utf8', async (err, data) =&gt; {\n  if (err) {\n    console.error('Erro ao ler o arquivo:', err)\n    return\n  }\n  \n  try {\n    const mimosaDB = JSON.parse(data)\n    const fjs = new FJS(mimosaDB)\n    const query = { 'leaf.bipinnate.pinnae.leaflet.numberOfPairs.min': { $gt: \"15\" } }\n    const output = await fjs.search(query)\n\n    const specificEpithets = output.result.map(item =&gt; item.specificEpithet)\n    console.log('Espécies encontradas:', specificEpithets)\n\n  } catch (error) {\n    console.error('Erro durante o processamento:', error)\n  }\n})\nExecute com:\nnode script2\nResultado:\nEspécies encontradas: [\n  'bimucronata',\n  'bocainae',\n  'dryandroides var. dryandroides',\n  'elliptica',\n  'invisa var. macrostachya',\n  'itatiaiensis',\n  'pilulifera var. pseudincana'\n]\nPara consultas com condições duplas (ex: maior que 15 e menor que 20), crie script3.js:\n// script3.js\nconst fs = require('fs')\nconst { FJS } = require('flex-json-searcher')\n\nconst filePath = './output/MimosaDB.json'\n\nfs.readFile(filePath, 'utf8', async (err, data) =&gt; {\n  if (err) {\n    console.error('Erro ao ler o arquivo:', err)\n    return\n  }\n  \n  try {\n    const mimosaDB = JSON.parse(data)\n    const fjs = new FJS(mimosaDB)\n\n    const gt15Query = { 'leaf.bipinnate.pinnae.leaflet.numberOfPairs.min': { $gt: \"15\" } }\n    const gt15Output = await fjs.search(gt15Query)\n\n    const fjs2 = new FJS(gt15Output.result)\n    const lt20Query = { 'leaf.bipinnate.pinnae.leaflet.numberOfPairs.min': { $lt: \"20\" } }\n    const lt20Output = await fjs2.search(lt20Query)\n\n    const results = lt20Output.result.map(item =&gt; item.specificEpithet)\n    console.log('Espécies com entre 15 e 20 pares de folíolos:', results)\n\n  } catch (error) {\n    console.error('Erro durante o processamento:', error)\n  }\n})\nExecute com:\nnode script3\nResultado:\nEspécies com entre 15 e 20 pares de folíolos:\n [ 'bimucronata', 'itatiaiensis', 'pilulifera var. pseudincana' ]\n\n\nConsulta de fontes\nPara consultar imagens obtidas por microscópio eletrônico, crie script4.js:\n// script4.js\nconst fs = require('fs')\nconst { FJS } = require('flex-json-searcher')\n\nconst filePath = './output/MimosaSourcesDB.json'\n\nfs.readFile(filePath, 'utf8', async (err, data) =&gt; {\n  if (err) {\n    console.error('Erro ao ler o arquivo:', err)\n    return\n  }\n  \n  try {\n    const mimosaSourcesDB = JSON.parse(data)\n    const fjs = new FJS(mimosaSourcesDB)\n    const query = { 'source.obtainingMethod': { $eq: \"photo\" } }\n    const output = await fjs.search(query)\n    console.log(output.result)\n  } catch (error) {\n    console.error('Erro durante o processamento:', error)\n  }\n})\nExecute com:\nnode script4\nResultado:\n[\n  {\n    index: '0',\n    path: '',\n    specificEpithet: 'afranioi',\n    source: {\n      obraPrinceps: 'yes',\n      sourceType: 'article',\n      authorship: 'Jordão, L.S.B. and Morim, M.P. and Simon, M.F., Dutra, V.F. and Baumgratz, J.F.A.',\n      year: 2021,\n      title: 'New Species of *Mimosa* (Leguminosae) from Brazil',\n      journal: 'Systematic Botany',\n      volume: 46,\n      number: 2,\n      pages: '339-351',\n      figure: '3',\n      obtainingMethod: 'photo'\n    }\n  },\n  {\n    index: '17',\n    ...\n  },\n  // ...\n]\nAs informações completas de cada fonte estão facilmente acessíveis, como sourceType (tipo de fonte), journal (periódico), figure (figura) e authorship (autoria).\n\n\nOutras aplicações de consulta\nO MongoDB e sua ferramenta complementar, o MongoDB Compass, oferecem capacidades avançadas de consulta (Figure 4.9). A linguagem de consulta do MongoDB, fortalecida por métodos como find() e um conjunto abrangente de operadores de comparação como $lt (menor que), $gt (maior que) e $eq (igual a), permite a filtragem precisa de documentos com base em critérios específicos. O MongoDB Compass, uma interface gráfica para o MongoDB, oferece uma plataforma intuitiva para construir e executar consultas visualmente. Ele simplifica a criação de consultas, a visualização de dados e a otimização, oferecendo uma representação gráfica amigável das estruturas de dados. Aproveitar o poder de consulta do MongoDB juntamente com a interface interativa do Compass permite que os usuários explorem, recuperem e manipulem dados de maneira eficaz em bancos de dados MongoDB.\n\n\n\n\n\n\nFigure 4.9: O MongoDB Compass oferece uma estrutura robusta para visualizar e investigar bancos de dados orientados a documentos, permitindo consultas poderosas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tutorial</span>"
    ]
  },
  {
    "objectID": "chamado.html",
    "href": "chamado.html",
    "title": "Chamada à ação",
    "section": "",
    "text": "Nem Word nem Excel, mas TypeTaxonScript. Estamos à beira de uma nova era nas descrições da taxonomia biológica. Nesta metodologia, são empregados métodos da engenharia de software usando TS para construir uma estrutura de dados robusta, promovendo esforços colaborativos duradouros e não redundantes através da aplicação de uma espécie de engenharia taxonômica dos corpos biológicos. Este programa inovador introduz uma nova abordagem para a documentação precisa e resiliente de táxons e caracteres, transcendendo as limitações dos editores de texto e planilhas tradicionais. O TypeTaxonScript simplifica e otimiza esse processo, permitindo descrições meticulosas e eficientes de organismos diversos, incluindo anotações, impulsionando a ciência da taxonomia e da sistemática a novos níveis de colaboração, precisão e eficácia.\nNo campo do trabalho colaborativo, mesmo diante de desafios, reside uma oportunidade crítica. Nossa proposta busca incentivar uma adoção mais ampla por parte da comunidade de biólogos, taxonomistas e sistematas. Este esforço implica fornecer uma infraestrutura de acesso aberto que facilite esforços colaborativos, alinhando-se com a criação de classes de objetos. Essa unidade assegura a integridade dos dados, eliminando a necessidade de descrições repetitivas de componentes fundamentais como a classe “folha” em diferentes iniciativas. Ao estruturar atributos das classes, estabelecemos uma abordagem simplificada que facilita o trabalho para futuros colaboradores. Cada descrição exige a instanciação dessas classes como objetos, promovendo uma abordagem semelhante à engenharia taxonômica para criar representações virtuais dos corpos biológicos.\nDentro dessa estrutura colaborativa, os papéis são claramente definidos — alguns se concentram na modelagem do banco de dados, enquanto outros se dedicam ao povoamento de dados. O processo de modelagem envolve a definição das classes de objetos que formam a base do banco de dados. Para alcançar consenso nessa tarefa dinâmica, o envolvimento da comunidade é essencial. Em casos de conflito, a resolução será gerida pelo responsável pelo repositório. Além disso, mesmo hipóteses conflitantes podem coexistir no mesmo banco de dados. Cada hipótese pode ser acomodada como uma classe distinta, permitindo perspectivas diversas e a convivência de diferentes pontos de vista. Essa abordagem inclusiva representa a essência da pesquisa colaborativa, onde as diferenças são valorizadas e contribuem para a riqueza do banco de dados.\nEm nosso banco de dados pré-construído (Lucas Sá Barreto Jordão 2024), adicionamos dados das seguintes publicações: Lucas Sá Barreto Jordão, Morim, and Baumgratz (2014), L. S. B. Jordão et al. (2017), Lucas S. B. Jordão, Morim, and Baumgratz (2018), Vieira et al. (2018) e Lucas Sá Barreto Jordão, Morim, and Baumgratz (2020). Além disso, incorporamos dados iniciais de um projeto de mineração de texto em Barneby (1991) (https://github.com/lsbjordao/PDF-scraping-Barneby), com o objetivo de compilar uma tabela com todos os caracteres derivados das descrições meticulosas.\n\n\n\n\nBarneby, R. C. 1991. Sensitivae Censitae: A Description of the Genus Mimosa Linnaeus (Mimosaceae) in the New World. Bronx, NY: New York Botanical Garden.\n\n\nJordão, L. S. B., M. P. Morim, J. F. A. Baumgratz, and M. F. Simon. 2017. “A New Species of Mimosa (Leguminosae) Endemic to the Brazilian Cerrado.” Phytotaxa 312 (2): 237. https://doi.org/10.11646/phytotaxa.312.2.6.\n\n\nJordão, Lucas S. B., Marli P. Morim, and José Fernando A. Baumgratz. 2018. “Toward a Census of Mimosa (Leguminosae) in the Atlantic Domain, Southeastern Brazil.” Syst Bot 43 (1): 162–97. https://doi.org/10.1600/036364418x696905.\n\n\nJordão, Lucas Sá Barreto. 2024. “lsbjordao/TTS-Mimosa: First release.” Zenodo. https://doi.org/10.5281/zenodo.10671076.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando A. Baumgratz. 2020. “Trichomes in Mimosa (Leguminosae): Towards a Characterization and a Terminology Standardization.” Flora 272 (November): 151702. https://doi.org/10.1016/j.flora.2020.151702.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando Andrade Baumgratz. 2014. “A New Species of Mimosa (Leguminosae) from Brazil.” Phytotaxa 184 (3): 131. https://doi.org/10.11646/phytotaxa.184.3.2.\n\n\nVieira, Leir Guimarães, Ravena Malheiros Nogueira, Elaine Cotrim Costa, Sheila Patrı́cia Carvalho-Fernandes, and Juliana Santos Silva. 2018. “Insect Galls in Rupestrian Field and Cerrado Stricto Sensu Vegetation in Caetité, Bahia, Brazil.” Biota Neotrop 18 (2). https://doi.org/10.1590/1676-0611-bn-2017-0402.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chamada à ação</span>"
    ]
  },
  {
    "objectID": "conclusao.html",
    "href": "conclusao.html",
    "title": "Conclusão",
    "section": "",
    "text": "O formato JSON ocupa uma posição única entre a simplicidade de uma planilha CSV e a estrutura formal de uma ontologia. No entanto, seu potencial permanece em grande parte inexplorado no campo da pesquisa em biodiversidade. Um dos fatores que contribuem para essa subutilização é a preferência de muitos biólogos sistemáticos por linguagens como R ao lidar com tarefas de programação, o que leva ao apego ao uso de ferramentas semelhantes a planilhas, como os dataframes.\nEmbora linguagens como R sejam escolhas populares por suas capacidades estatísticas especializadas, elas não oferecem suporte nativo à manipulação de JSON. Além disso, ferramentas como o RStudio, frequentemente preferidas por biólogos, podem não oferecer o mesmo nível de eficiência e versatilidade encontrado em IDEs como o VS Code. Esse apego ao armazenamento de dados em planilhas pode derivar de sua familiaridade e facilidade de uso, mesmo que limitem a representação de estruturas e relações de dados complexas, nas quais o JSON se destaca.\nA integração do JSON no ecossistema da programação orientada a objetos (OOP) e do TypeScript abre uma oportunidade para preencher essa lacuna. Ao demonstrar como bancos de dados JSON podem representar efetivamente relações e estruturas complexas inerentes aos dados biológicos, pesquisadores podem ser incentivados a explorar métodos alternativos de armazenamento de dados. Isso pode facilitar o compartilhamento de dados, a interoperabilidade e o desenvolvimento de métodos analíticos inovadores, ao mesmo tempo que atende ao apego de alguns biólogos às planilhas.\nÀ medida que o campo da pesquisa em biodiversidade continua a se expandir e a integrar avanços tecnológicos, adotar o JSON como formato de dados fundamental pode levar a uma maior integridade dos dados, fluxos de trabalho mais eficientes e descobertas aceleradas. Ao fornecer aos biólogos ferramentas para gerenciar e manipular dados JSON com facilidade, essa estrutura integrada tem o potencial de mudar a tendência de armazenamento baseado em planilhas para abordagens mais poderosas, sem esquema fixo, baseadas em documentos e colaborativas — impulsionando o campo para novos horizontes de entendimento e exploração.\nAntes de abordar preocupações sobre a necessidade de implementação de um banco de dados para descrições de espécimes (indivíduos), é fundamental esclarecer que um de nossos marcos é a criação de um banco de dados capaz de acomodar descrições detalhadas de espécimes. No entanto, o processo de implementação requer consideração cuidadosa, devido a muitas outras complexidades que surgem em relação à consistência dos dados, como a ausência de definição de tipos de dados em dados legados associados a bancos de dados de coleções biológicas. Dada a natureza intrincada e variada das informações ligadas a cada espécime — incluindo características físicas, origens geográficas e históricos de coleta —, o desenvolvimento de uma estrutura de banco de dados flexível e escalável é essencial. Analisar os requisitos específicos do projeto, selecionar tecnologias adequadas e definir um esquema de dados robusto são aspectos fundamentais para o sucesso desse esforço. Além disso, embora armazenar descrições de espécimes no TTS possa não ser o ideal, seus princípios podem inspirar a criação de um pacote dedicado, como o TypeTaxonScript-specimens.\nO TypeTaxonScript apresenta uma abordagem inovadora para a criação e desenvolvimento colaborativo de bancos de dados. Sua estrutura versátil não apenas facilita a construção coletiva de repositórios de dados robustos, como também convida usuários, inclusive leitores, a explorar e criar novas aplicações. A adaptabilidade desse método transcende os limites convencionais, capacitando indivíduos e comunidades a imaginar e implementar usos diversos que ressoem com suas necessidades específicas. À medida que nos aprofundamos no campo da curadoria colaborativa de dados, o potencial para aplicações novas e impactantes permanece vasto, aguardando a criatividade de cada participante para moldar seus futuros caminhos.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Conclusão</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Ashburner, Michael, Catherine A. Ball, Judith A. Blake, David Botstein,\nHeather Butler, J. Michael Cherry, Allan P. Davis, et al. 2000.\n“Gene Ontology: Tool for the Unification of Biology.”\nNat Genet 25 (1): 25–29. https://doi.org/10.1038/75556.\n\n\nBaazizi, Mohamed-Amine, Dario Colazzo, Giorgio Ghelli, and Carlo\nSartiani. 2019. “Schemas and Types for JSON\nData.” In Proceedings of the 2019 International Conference on\nManagement of Data. ACM. https://doi.org/10.1145/3299869.3314032.\n\n\nBarneby, R. C. 1991. Sensitivae Censitae: A Description of the Genus\nMimosa Linnaeus (Mimosaceae) in the New World. Bronx, NY:\nNew York Botanical Garden.\n\n\nBedathur, Srikanta J, Jayant R Haritsa, and Uday S Sen. 2003. “The\nBuilding of BODHI, a Bio-Diversity Database System.” Inf\nSyst 28 (4): 347–67. https://doi.org/10.1016/S0306-4379(02)00073-X.\n\n\nBlischak, John D., Emily R. Davenport, and Greg Wilson. 2016. “A\nQuick Introduction to Version Control with Git and\nGitHub.” Edited by Francis Ouellette.\nPLoS Comput 12 (1): e1004668. https://doi.org/10.1371/journal.pcbi.1004668.\n\n\nChai, Hualei, Gang Wu, and Yuan Zhao. 2013. “A Document-Based Data\nWarehousing Approach for Large Scale Data Mining.” In\nPervasive Computing and the Networked World, 69–81. Springer\nBerlin Heidelberg. https://doi.org/10.1007/978-3-642-37015-1_7.\n\n\nChickerur, Satyadhyan, Anoop Goudar, and Ankita Kinnerkar. 2015.\n“Comparison of Relational Database with Document-Oriented Database\n(MongoDB) for Big Data Applications.” In 2015 8th\nInternational Conference on Advanced Software Engineering & Its\nApplications (ASEA), 41–47. https://doi.org/10.1109/ASEA.2015.19.\n\n\nCooper, Laurel, Ramona L. Walls, Justin Elser, Maria A. Gandolfo, Dennis\nW. Stevenson, Barry Smith, Justin Preece, et al. 2012. “The Plant\nOntology as a Tool for Comparative Plant Anatomy and Genomic\nAnalyses.” Plant and Cell Physiology 54 (2): e1–1. https://doi.org/10.1093/pcp/pcs163.\n\n\nCrystal-Ornelas, Robert, Charuleka Varadharajan, Ben Bond-Lamberty,\nKristin Boye, Madison Burrus, Shreyas Cholia, Michael Crow, et al. 2021.\n“A Guide to Using GitHub for Developing and\nVersioning Data Standards and Reporting Formats.” Earth Space\nSci 8 (8). https://doi.org/10.1029/2021ea001797.\n\n\nDiPierro, Massimo. 2018. “The Rise of JavaScript.”\nComput Sci Eng 20 (1): 9–10. https://doi.org/10.1109/MCSE.2018.011111120.\n\n\nECMA International. 2023. ECMAScript Language Specification.\nECMA International. https://www.ecma-international.org/publications/standards/Ecma-262.htm.\n\n\nGene Ontology Consortium, Suzi A Aleksander, James Balhoff, Seth Carbon,\nJ Michael Cherry, Harold J Drabkin, Dustin Ebert, et al. 2023.\n“The Gene Ontology Knowledgebase in 2023.”\nGenetics 224 (1). https://doi.org/10.1093/genetics/iyad031.\n\n\nJanicki, Julia, Nitish Narula, Matt Ziegler, Benoit Guénard, and Evan P.\nEconomo. 2016. “Visualizing and Interacting with Large-Volume\nBiodiversity Data Using Client–Server Web-Mapping Applications: The\nDesign and Implementation of Antmaps.org.” Ecol Inform\n32: 185–93. https://doi.org/10.1016/j.ecoinf.2016.02.006.\n\n\nJordão, L. S. B., M. P. Morim, J. F. A. Baumgratz, and M. F. Simon.\n2017. “A New Species of Mimosa (Leguminosae) Endemic to the\nBrazilian Cerrado.” Phytotaxa 312 (2): 237. https://doi.org/10.11646/phytotaxa.312.2.6.\n\n\nJordão, Lucas S. B., Marli P. Morim, and José Fernando A. Baumgratz.\n2018. “Toward a Census of Mimosa (Leguminosae) in the Atlantic\nDomain, Southeastern Brazil.” Syst Bot 43 (1): 162–97.\nhttps://doi.org/10.1600/036364418x696905.\n\n\nJordão, Lucas Sá Barreto. 2024. “lsbjordao/TTS-Mimosa: First release.”\nZenodo. https://doi.org/10.5281/zenodo.10671076.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando A.\nBaumgratz. 2020. “Trichomes in Mimosa (Leguminosae): Towards a\nCharacterization and a Terminology Standardization.”\nFlora 272 (November): 151702. https://doi.org/10.1016/j.flora.2020.151702.\n\n\nJordão, Lucas Sá Barreto, Marli Pires Morim, and José Fernando Andrade\nBaumgratz. 2014. “A New Species of Mimosa (Leguminosae) from\nBrazil.” Phytotaxa 184 (3): 131. https://doi.org/10.11646/phytotaxa.184.3.2.\n\n\nJSON Schema. 2023. TypeScript. JSON Schema. https://www.json.org/json-pt.html.\n\n\nKarnitis, Girts, and Guntis Arnicans. 2015. “Migration of\nRelational Database to Document-Oriented Database: Structure\nDenormalization and Data Transformation.” In 2015 7th\nInternational Conference on Computational Intelligence, Communication\nSystems and Networks, 113–18. https://doi.org/10.1109/CICSyN.2015.30.\n\n\nLin, Jimmy, and Kareem El Gebaly. 2016. “The Future of Big Data\nIs... JavaScript?” IEEE Internet\nComput 20 (5): 82–88. https://doi.org/10.1109/mic.2016.109.\n\n\nMason, Robert Thomas. 2015. “NoSQL Databases and Data\nModeling for a Document-Oriented NoSQL Database.” In\nInSITE Conference. Informing Science Institute. https://doi.org/10.28945/2245.\n\n\nMicrosoft Corporation. 2023. TypeScript. Microsoft. https://www.typescriptlang.org/.\n\n\nMorim, Marli Pires, and Eimear M. Nic Lughadha. 2015. “Flora of\nBrazil Online: Can Brazils Botanists Achieve Their 2020\nVision?” Rodriguesia 66 (4): 1115–35. https://doi.org/10.1590/2175-7860201566412.\n\n\nNode.js Contributors. 2023. Node.js. Node.js Foundation. https://nodejs.org/.\n\n\nOlivera, Harley Vera, Maristela Terto de Holanda, Valeria Guimarâes,\nFernanda Hondo, and Wagner Boaventura. 2015. “Data Modeling for\nNoSQL Document-Oriented Databases.” In Symposium on\nInformation Management and Big Data. https://api.semanticscholar.org/CorpusID:15589232.\n\n\nOnkov, Kolyo. 2011. “Object Oriented Modelling in Information\nSystems Based on Related Text Data.” In IFIP Adv\nInf Commun Technol, 212–18. https://doi.org/10.1007/978-3-642-23960-1_26.\n\n\nPerez-Riverol, Yasset, Laurent Gatto, Rui Wang, Timo Sachsenberg, Julian\nUszkoreit, Felipe da Veiga Leprevost, Christian Fufezan, et al. 2016.\n“Ten Simple Rules for Taking Advantage of Git and\nGitHub.” Edited by Scott Markel.\nPLoS Comput 12 (7): e1004947. https://doi.org/10.1371/journal.pcbi.1004947.\n\n\nPerkel, Jeffrey. 2016. “Democratic Databases: Science on\nGitHub.” Nature 538 (7623): 127–28. https://doi.org/10.1038/538127a.\n\n\nRai, Sawan, Ramesh Chandra Belwal, and Atul Gupta. 2022. “A Review\non Source Code Documentation.” ACM Trans Intell\nSyst Technol 13 (5): 1–44. https://doi.org/10.1145/3519312.\n\n\nSarkar, Indra, Ryan Schenk, and Catherine N Norton. 2008.\n“Exploring Historical Trends Using Taxonomic Name\nMetadata.” BMC Evol Biol 8 (1): 144. https://doi.org/10.1186/1471-2148-8-144.\n\n\nSequeira, R. A., R. L. Olson, and J. M. McKinion. 1997.\n“Implementing Generic, Object-Oriented Models in Biology.”\nEcol Model 94 (1): 17–31. https://doi.org/10.1016/S0304-3800(96)01925-4.\n\n\nSilva, Thiago Sanches Ranzani da. 2017. “Species Descriptions and\nDigital Environments: Alternatives for Accessibility of Morphological\nData.” Rev Bras Entomol 61 (4): 277–81. https://doi.org/10.1016/j.rbe.2017.06.005.\n\n\nSpinellis, Diomidis. 2010. “Code Documentation.”\nIEEE Softw 27 (4): 18–19. https://doi.org/10.1109/ms.2010.95.\n\n\nTylman, Wojciech. 2016. “Computer Science and Philosophy: Did\nPlato Foresee Object-Oriented Programming?” Found Sci 23\n(1): 159–72. https://doi.org/10.1007/s10699-016-9506-7.\n\n\nVieira, Leir Guimarães, Ravena Malheiros Nogueira, Elaine Cotrim Costa,\nSheila Patrı́cia Carvalho-Fernandes, and Juliana Santos Silva. 2018.\n“Insect Galls in Rupestrian Field and Cerrado Stricto Sensu\nVegetation in Caetité, Bahia, Brazil.” Biota\nNeotrop 18 (2). https://doi.org/10.1590/1676-0611-bn-2017-0402.\n\n\nWalls, Ramona L., Balaji Athreya, Laurel Cooper, Justin Elser, Maria A.\nGandolfo, Pankaj Jaiswal, Christopher J. Mungall, et al. 2012.\n“Ontologies as Integrative Tools for Plant Science.”\nAmerican Journal of Botany 99 (8): 1263–75. https://doi.org/10.3732/ajb.1200222.\n\n\nWarren, Alan, David J. Patterson, Micah Dunthorn, John C. Clamp, Undine\nE. M. Achilles-Day, Erna Aescht, Saleh A. Al-Farraj, et al. 2017.\n“Beyond the “Code”: A Guide to the\nDescription and Documentation of Biodiversity in Ciliated Protists\n(Alveolata, Ciliophora).” J Eukaryot 64 (4): 539–54. https://doi.org/10.1111/jeu.12391.\n\n\nWegner, Peter. 1990. “Concepts and Paradigms of Object-Oriented\nProgramming.” ACM SIGPLAN\nOOPS Messenger 1 (1): 7–87. https://doi.org/10.1145/382192.383004.\n\n\nWinston, Judith E. 1999. Describing Species: Practical Taxonomic\nProcedure for Biologists. Columbia University Press. http://www.jstor.org/stable/10.7312/wins06824.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução ao ",
    "section": "",
    "text": "Resumo\nA programação orientada a objetos (POO) representa um paradigma de desenvolvimento de software baseado na representação de entidades do mundo real como objetos, facilitando uma abordagem de modelagem mais eficiente e estruturada. Neste artigo, exploramos a sinergia entre os princípios da POO e a linguagem de programação TypeScript (TS) para criar um banco de dados no formato JSON, projetado para armazenar arrays de características biológicas. Essa fusão de tecnologias promove um script de código controlado e modular, simplificando a integração, manipulação, expansão e análise de dados biológicos, ao mesmo tempo que aprimora a sintaxe para uma melhor legibilidade humana, como o uso da notação de ponto. Defendemos que biólogos adotem a tecnologia Git, semelhante às práticas de programadores e codificadores, para iniciar projetos versionados e colaborativos. O uso do IDE amplamente acessível e renomado, o Visual Studio Code, oferece uma vantagem adicional. Ele não só suporta a execução de um ambiente Node.js, essencial para rodar TS, mas também gerencia eficientemente o versionamento do GitHub. Apresentamos um caso de uso envolvendo a estrutura de dados taxonômica, com foco nas plantas leguminosas angiospermas. Esse método é caracterizado pela sua simplicidade, uma vez que as ferramentas empregadas são totalmente acessíveis e gratuitas, além de ser amplamente adotado por comunidades de programadores profissionais. Além disso, estamos dedicados a facilitar a implementação prática e a compreensão por meio de um tutorial abrangente, um banco de dados pré-construído disponível no GitHub e um novo pacote no npm.",
    "crumbs": [
      "Resumo"
    ]
  }
]